+++
title = "So You Wanna Build A Web Crawler"
subtitle = ""
date = "2025-04-20T00:00:00.000Z"
summary = ""
draft = false
featured = false
authors = ["admin"]
tags = ["blog"]
categories = []
projects = []
images = ["webcrawl.png"]
+++

![image](webcrawl.png)

Web crawling at scale involves fetching and processing billions of pages across the internet. Achieving this requires robust tools and careful design to handle distribution, deduplication, and real‑time updates. This guide compiles **practical resources** – from open‑source frameworks to engineering blogs and influential academic papers – to help you get up and running quickly with existing crawlers while also gaining a deep understanding of large‑scale crawling systems. We organize the information by frameworks, design patterns (distributed crawling, deduplication, etc.), batch vs. real‑time crawling, and performance considerations, with links and references for further reading.

## Frameworks and Tools for Large‑Scale Crawling

Modern crawling frameworks can save you from re‑inventing the wheel. Below are widely used open‑source tools – each with different strengths – and resources on using or extending them:

- **Scrapy (Python):** A fast, high‑level web crawling & scraping framework [(Link)](https://docs.scrapy.org/en/latest/). Scrapy is great for quick development of crawlers and can be scaled out by running multiple instances (e.g. via Scrapyd or a container cluster). While Scrapy is not a distributed crawler out‑of‑the‑box, projects like **Scrapy + Frontera** (a distributed frontier) enable large‑scale, multi‑node crawling [(Link)](https://docs.scrapy.org/en/latest/). For example, Zyte’s engineering blog details how their **Frontera** framework (funded by DARPA) can coordinate a crawl of _around 1 billion pages per week_ using Scrapy spiders with Kafka and HBase [(Link)](https://www.zyte.com/blog/scrapy-frontera-scalable-open-source-crawling/) [(Link)](https://www.zyte.com/blog/scrapy-frontera-scalable-open-source-crawling/). This architecture partitions URLs by domain to ensure each domain is handled by one spider, achieving scale while respecting politeness [(Link)](https://www.zyte.com/blog/scrapy-frontera-scalable-open-source-crawling/) [(Link)](https://www.zyte.com/blog/scrapy-frontera-scalable-open-source-crawling/).

- **Heritrix (Java):** The Internet Archive’s open‑source, “**web‑scale, archival‑quality**” crawler [(Link)](https://github.com/internetarchive/heritrix3). Heritrix is designed for broad crawls (e.g. archiving the whole web) and has been used by national libraries and archives worldwide. It supports extensive configuration, politeness, and checkpointing. Heritrix stores crawled data in **WARC/ARC** formats for archival storage [(Link)](https://github.com/internetarchive/heritrix3/wiki/User-Manual). While Heritrix runs as a powerful single‑node crawler (multithreaded), it can be run in parallel on multiple seed segments for higher throughput. _Resource:_ The Heritrix user manual (on the IA GitHub wiki) provides guidance on tuning crawl breadth, deduplication, and configurations for large crawl jobs.

- **Apache Nutch (Java):** A highly extensible, **scalable** open‑source web crawler that originated from the Lucene project [(Link)](https://nutch.apache.org/). Nutch is built to run **batch‑oriented** crawls on Hadoop – it treats crawling as a series of MapReduce jobs for fetching, parsing, deduplicating, and indexing content [(Link)](https://nutch.apache.org/). This makes it ideal for **large batch crawls** over massive URL sets. Nutch’s integration with Hadoop means it can easily scale to billions of pages using a cluster, at the cost of latency (crawling in cycles rather than continuous). Nutch was proven at scale in 2003 by crawling 100 million pages and in fact led to the creation of Hadoop’s HDFS and MapReduce (which evolved out of Nutch’s needs) [(Link)](https://nutch.apache.org/). **Common Crawl**, the non‑profit web corpus, adopted Nutch for its early open web crawls [(Link)](https://nutch.apache.org/). _Resource:_ _A Complete Web Crawling Guide with Apache Nutch_ [(Link)](https://www.ereyes.net/blog/guide-to-web-crawling-with-apache-nutch/) [(Link)](https://www.ereyes.net/blog/guide-to-web-crawling-with-apache-nutch/) (tutorial) and Nutch’s official docs cover setting up a crawl, using plugins (for parsing with Tika, indexing to Solr/Elasticsearch [(Link)](https://wiki.apache.org/nutch/IndexingWithSolr)), and performance tuning.

- **Apache StormCrawler (Java):** A toolkit for building **low‑latency, distributed** crawlers on top of Apache Storm (stream processing) [(Link)](https://stormcrawler.net/). StormCrawler is essentially a collection of reusable components (“spouts” and “bolts”) that handle fetching, parsing, URL discovery, etc., which you can assemble into a real‑time crawling topology. It is designed for **real‑time or continuous crawling**, where URLs are fed in a stream and processed immediately, as opposed to batch. StormCrawler emphasizes being _scalable, resilient, and polite_ (it has built‑in politeness control) [(Link)](https://stormcrawler.net/). This makes it suitable for use cases like news feeds or incremental crawls that require quick turnaround. _Resource:_ The official StormCrawler site and FAQ [(Link)](https://stormcrawler.net/#faq) [(Link)](https://stormcrawler.net/) provide architecture overviews and example deployments (including integration with Elasticsearch for indexing).

- **Other Notable Tools:**

  - _Crawler4j_ (Java) – a simple crawler library for Java that can multi‑thread, suitable for moderate‑scale crawls on a single server.
  - _BUbiNG_ (Java) – a newer high‑performance distributed crawler from researchers Boldi et al. (2014). BUbiNG is fully distributed and **open source**, built upon lessons from the earlier UbiCrawler system [(Link)](https://github.com/LAW-Unimi/bubing). A single BUbiNG instance on decent hardware can crawl **several thousand pages per second** while respecting politeness (both host and IP limits) [(Link)](https://github.com/LAW-Unimi/bubing). Unlike Hadoop‑based crawlers, BUbiNG uses a continuous crawling approach with high‑speed messaging between crawler nodes for URL distribution [(Link)](https://github.com/LAW-Unimi/bubing). This project fills a gap for an open‑source crawler that scales linearly with resources [(Link)](https://github.com/LAW-Unimi/bubing).
  - _Frontera (Scrapy Frontier)_ – mentioned above, for extending Scrapy with a scalable frontier backend [(Link)](https://docs.scrapy.org/en/latest/). It allows plugging in different backends (SQL, NoSQL) for URL queue and can distribute URL handling among workers.
  - _Common Crawl’s Codebase_ – while not a tool to run out‑of‑box, CommonCrawl has open‑sourced parts of its pipeline [(Link)](https://github.com/commoncrawl). Their older Hadoop‑based crawler (2008–2013) architecture is documented in slides and articles (see **Case Studies** below).

  _Example: a distributed crawling architecture using Scrapy + Frontera._ In this design, multiple Scrapy **Spiders** fetch pages, while a Kafka‑based **Spider Log** feeds discovered URLs to “Strategy Workers” (for crawl prioritization) and “DB Workers” that interface with a scalable storage (HBase) for the URL frontier. This allows an arbitrary number of URLs to be handled in batches, and ensures only one spider hits a given domain at a time [(Link)](https://www.zyte.com/blog/scrapy-frontera-scalable-open-source-crawling/) [(Link)](https://www.zyte.com/blog/scrapy-frontera-scalable-open-source-crawling/). The system can continuously generate new URL batches and scoring logs for prioritization.

## Distributed Crawling Architecture and Design Patterns

Building a large‑scale crawler from scratch requires addressing key challenges in a **distributed system**: how to partition the crawling work, maintain a URL frontier, avoid overloading servers, and eliminate duplicates. Below we outline the core components and design patterns, with references to both engineering guides and academic research that influenced real‑world systems:

- **URL Frontier & Scheduling:** The _URL frontier_ is the data structure holding discovered URLs yet to crawl. At web scale this can grow huge (potentially billions of URLs), so it often lives on disk or in distributed storage. A naive single FIFO queue is insufficient – we need to support **prioritization** (to crawl important or fresh URLs sooner) and **politeness** (to avoid hitting the same site too fast). A classic solution, introduced by the **Mercator** crawler, is a **two‑stage frontier** [(Link)](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36991.pdf):

  1. A _front‑end_ that picks the next URL to crawl based on priority (e.g. highest score or earliest discovered).
  2. A _back‑end_ consisting of per‑host (or per‑domain) FIFO queues that enforce politeness delays [(Link)](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36991.pdf).  
     This way, the crawler can prioritize globally but still fetch from many hosts in parallel without overloading any single host. Mercator’s design has been highly influential – most modern crawlers (Nutch, Heritrix, BUbiNG, etc.) implement some variant of this queued scheduling [(Link)](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36991.pdf) [(Link)](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36991.pdf). _Resource:_ Najork’s “Web Crawler Architecture” explains this two‑tier queue and other data structures [(Link)](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36991.pdf).

- **Distributed Partitioning:** In a cluster of crawling nodes, we must decide how to split the URL space. Two common patterns are **dynamic assignment** and **static assignment** [(Link)](https://www.cs.tufts.edu/comp/165/archive/fall2015/shkapenyuk-crawler.pdf) [(Link)](https://www.cs.tufts.edu/comp/165/archive/fall2015/shkapenyuk-crawler.pdf):

  - _Dynamic assignment:_ A central coordinator dynamically assigns URLs to crawler nodes. This can simplify load balancing (the coordinator can give more URLs to less‑busy nodes), but the central server can become a bottleneck if it must handle millions of URLs/sec [(Link)](https://www.cs.tufts.edu/comp/165/archive/fall2015/shkapenyuk-crawler.pdf). Systems like early Google or Yahoo crawlers used centralized coordination but scaled by having the coordinator distribute work to thousands of machines [(Link)](https://www.cs.tufts.edu/comp/165/archive/fall2015/shkapenyuk-crawler.pdf) (with hierarchical structures to avoid a single point of failure).
  - _Static assignment:_ Each crawler node is responsible for a specific subset of URLs (often based on a **hash of the hostname or domain**). For example, using a hash function on the URL’s domain, we route URLs to nodes such that each node handles a deterministic portion of the web [(Link)](https://www.cs.tufts.edu/comp/165/archive/fall2015/shkapenyuk-crawler.pdf). This avoids a central bottleneck; crawlers mostly work independently, occasionally exchanging URLs that belong to each other’s partitions (e.g. when a page on Node A contains a link that hashes to Node B) [(Link)](https://www.cs.tufts.edu/comp/165/archive/fall2015/shkapenyuk-crawler.pdf). UbiCrawler (2004) used this approach to achieve a fully P2P crawler with no central server [(Link)](https://github.com/LAW-Unimi/bubing). _Note:_ Static partitioning benefits from _balanced distribution_ (so no node gets too many popular sites) and may use a precomputed list of popular domains that all nodes know about to reduce cross‑node communication [(Link)](https://www.cs.tufts.edu/comp/165/archive/fall2015/shkapenyuk-crawler.pdf).

- **URL Uniqueness & Deduplication:** At scale, ensuring each URL is crawled once (and avoiding infinite loops) is non‑trivial. A **URL seen set** must be maintained, often requiring memory/disk trade‑offs. Using a hash of each URL (e.g. 64‑bit or 128‑bit fingerprint) is standard for memory efficiency [(Link)](https://github.com/commoncrawl/commoncrawl-documentation). For example, Common Crawl’s pipeline uses 128‑bit URL fingerprints as keys in its CrawlDB [(Link)](https://github.com/commoncrawl/commoncrawl-documentation). If memory permits, a hash‑set or Bloom filter in RAM can check seen‑URLs quickly; otherwise, disk‑based solutions are needed. **IRLbot**, a research crawler that scaled to 6 + billion pages on one server, introduced a high‑performance disk‑based structure called **DRUM (Disk Repository with Update Management)** for URL deduplication [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c). DRUM batches URL fingerprints and writes them in sorted runs, achieving thousands of URL insertions per second with minimal seeks [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c). This solved a major bottleneck – IRLbot noted that naive uniqueness checks became a limiting factor at billions of URLs without such optimization [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c). _Resource:_ The IRLbot WWW’08 paper (Lee et al.) is full of such practical techniques for URL management [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c) [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c).

- **Content Deduplication (Near‑duplicates):** Large web crawls inevitably fetch many pages with identical or very similar content (e.g. mirror sites, session IDs creating duplicate pages). Storing and processing duplicates is wasteful, so crawlers often do **content fingerprinting** to detect and skip duplicates. A famous approach from Google is **SimHash** – a fingerprint that preserves similarity, so that near‑duplicate pages have fingerprints that differ in only a few bits. This allows clustering of near‑identical content by comparing hashes efficiently [(Link)](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/33026.pdf). In practice, crawlers may compute an MD5 or SHA‑1 of normalized text for exact duplicates and use SimHash or shingling techniques for near‑duplicates [(Link)](https://github.com/commoncrawl/commoncrawl-documentation). For example, Common Crawl’s pipeline includes a MapReduce phase for parsing and deduplicating content by computing checksums and skipping any page whose content hash was seen already [(Link)](https://github.com/commoncrawl/commoncrawl-documentation). Academic literature (Broder 2000; Manku et al. 2007 [(Link)](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/33026.pdf)) provides algorithms that real systems like Google have used to eliminate massive duplicate content.

- **Politeness and Throttling:** A robust crawler must **respect robots.txt and avoid overloading websites**. This typically means:

  - Obeying the `robots.txt` directives on each site (crawling only allowed paths).
  - Limiting the fetch rate per domain (e.g. introducing a delay of a few seconds between successive requests to the same server). The frontier’s per‑host queues facilitate this by dequeuing URLs for a host only after a certain delay.
  - Using multiple DNS resolver threads or caches – since DNS lookups for new hosts can be a bottleneck, large crawlers often run a local DNS cache or even a dedicated DNS server cluster.
  - Monitoring HTTP response codes to adaptively slow down if a site shows signs of stress (500 errors) or speed up if it's very fast and allows rapid fetching.

  Many frameworks have these features built‑in (Heritrix and Nutch allow configuring politeness delay, parallel fetches per host, etc.). IRLbot introduced an interesting strategy called **STAR (Spam Tracking and Avoidance through Reputation)** to dynamically decide how many pages to crawl from a domain based on its link popularity [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c). Essentially, domains with few incoming links (likely low‑quality or spam) were given a low crawl budget to avoid spider traps, whereas highly referenced domains could be crawled deeper [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c). This kind of adaptive politeness/spam control is important in large‑scale broad crawls.

- **Real‑Time vs. Batch Crawling:** There are two paradigms to crawling:

  - _Batch Crawling:_ The crawl operates in discrete rounds. You start with a seed list, fetch a huge wave of pages, collect outlinks, then (in a next “round”) fetch those, and so on. Apache Nutch and the CommonCrawl pipeline follow this model [(Link)](https://nutch.apache.org/) [(Link)](https://www.slideshare.net/ahad-rana/building-a-scalable-web-crawler-with-hadoop) – e.g., generate a batch of URLs, fetch them, parse and deduplicate in bulk, update the crawl DB, then repeat. Batch crawling is efficient for maximizing throughput and is easier to implement on Hadoop or via queues. The downside is **latency**: new pages or updates aren’t seen until the next batch. Common Crawl’s 2010 architecture, for instance, was batch‑oriented: independent crawler nodes dumped data into HDFS, and MapReduce jobs handled parsing, deduping, and building indices (link graphs, etc.) after each crawl checkpoint [(Link)](https://www.slideshare.net/ahad-rana/building-a-scalable-web-crawler-with-hadoop) [(Link)](https://github.com/commoncrawl/commoncrawl-documentation).
  - _Real‑Time (Continuous) Crawling:_ The crawler continuously discovers and fetches new URLs in near‑immediate fashion. This is needed for _freshness_ (e.g. news sites, social media links). A real‑time crawler often runs as a persistent service or streaming job (like StormCrawler on Storm, or a custom event‑driven system). Newly discovered URLs are immediately queued for fetching without waiting for a global cycle. Google’s indexing system after the **Caffeine** update (circa 2010) moved toward more continuous crawling and indexing to keep search results fresh. Open‑source tools like StormCrawler enable building such always‑on crawlers, where URL streams are handled with low latency [(Link)](https://stormcrawler.net/). The complexity here is maintaining the state (visiting history, priorities) in a long‑running process, but tools like Kafka + HBase (as used in Scrapy/Frontera’s distributed mode) or other messaging systems can help manage this state across components [(Link)](https://www.zyte.com/blog/scrapy-frontera-scalable-open-source-crawling/) [(Link)](https://www.zyte.com/blog/scrapy-frontera-scalable-open-source-crawling/).

  In practice, large search engines combine both approaches: a continuous crawl for high‑priority pages (popular news sites, etc.) and periodic batch crawls to expand coverage.

## Engineering Insights and Performance Considerations

**Bottlenecks** in web crawlers can be surprising. A well‑designed large crawler must balance CPU, network, and disk use. Some hard‑earned insights from real‑world implementations and papers include:

- _Network and I/O:_ Fetching millions of pages is I/O-intensive. High‑end crawlers use asynchronous IO or multi‑threading to keep network utilization high. For example, IRLbot sustained an average download rate of ~319 Mb/s (around 1,789 pages/s) on a single server with 16 GB RAM and a 1 Gbps link [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c). It did this by using threads (or non‑blocking IO) and careful disk handling. When writing page data to disk, batching and sequential writes are crucial (to avoid random disk seeks). Common Crawl’s Hadoop approach writes large segment files and uses sequence files/WARCs to store multiple pages per file for efficiency [(Link)](https://github.com/commoncrawl/commoncrawl-documentation). Modern crawlers on SSDs or distributed file stores can further alleviate disk seek limitations.

- _DNS resolution:_ This is often a hidden bottleneck – every new domain requires a DNS lookup, which can take tens of milliseconds and block the crawler. Solutions include caching DNS results, doing bulk lookups, or running a local DNS server. Mercator incorporated a custom DNS cache module to reuse lookups [(Link)](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36991.pdf). Large systems may pre‑resolve a list of known domains or maintain persistent DNS resolver threads.

- _Data Structures (memory vs disk):_ As mentioned, maintaining large sets (for seen URLs or frontier queues) on disk is challenging. Mercator showed that exploiting the locality of URL discovery (new URLs often share domains with recent ones) can let disk‑based structures work by grouping writes [(Link)](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36991.pdf). BUbiNG (2014) uses in‑memory queues as much as possible and spills to disk efficiently when needed, while leveraging modern hardware (lots of RAM, fast networks). Tuning the **heap/queue sizes**, and using compression for stored data (like URL lists) can greatly improve performance. For example, using front compression on URL strings or storing only URL hashes can reduce memory footprint.

- _Multi‑datacenter Crawling:_ Big commercial crawlers (Google, Bing) distribute load across data centers. Najork notes that one strategy is **geographically distributed crawlers** – each data center crawls part of the web and then shares the data or indices with others [(Link)](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36991.pdf) [(Link)](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36991.pdf). This can reduce latency to nearby websites and divide the task by region or by content type. While likely out of scope for most projects, it’s interesting that global‑scale crawling involves replication and merging results from multiple crawler instances.

- _Open‑source vs Custom Performance:_ Academic projects like IRLbot and BUbiNG demonstrate that a well‑optimized custom crawler can achieve incredible performance on limited hardware (IRLbot’s single‑server 6 billion page crawl [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c)). However, these require expertise and low‑level optimizations in C/C++ or Java. Existing frameworks (Scrapy, Nutch, etc.) may not reach those extremes out‑of‑the‑box, but they trade some performance for ease of use and extensibility. If you need to crawl tens of millions of pages quickly, frameworks like Nutch or StormCrawler on a cluster can likely get you there with modest tuning, whereas beyond that scale, applying techniques from the literature (disk‑based URL hashing, highly concurrent IO, etc.) becomes necessary.

## Notable Case Studies and References

To deepen understanding, here are some **influential papers and real‑world case studies** in large‑scale crawling, and what they contributed:

- **The Anatomy of a Search Engine (Brin & Page, 1998):** Although focused on Google’s early indexing, it described Google’s original crawler: it ran on several distributed machines, kept a URL queue in memory, and achieved 100+ Mbps crawling speed even in 1998. It introduced the importance of page prioritization (PageRank was used to prioritize URLs). _Influence:_ Established the need for large clusters of focused crawlers for web search engines [(Link)](https://www.cs.tufts.edu/comp/165/archive/fall2015/shkapenyuk-crawler.pdf).

- **Mercator (Heydon & Najork, 1999):** The first published crawler architecture designed for scalability [(Link)](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/mercator.pdf). Mercator was written in Java and introduced a modular design with interfaces for key components (DNS resolver, URL frontier, etc.), making it extensible [(Link)](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/mercator.pdf). It implemented the two‑stage frontier and showed how to integrate politeness in a scalable way. _Influence:_ Many subsequent crawlers (academic and industrial) borrowed Mercator’s architecture. Najork’s later article [(Link)](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36991.pdf) summarizes these components.

- **Shkapenyuk & Suel (2002):** “Design and Implementation of a High‑Performance Crawler” – detailed a multi‑threaded crawler that achieved very high download rates. It discussed architectures for small vs. large crawlers (centralized vs. distributed queues) [(Link)](https://www.cs.tufts.edu/comp/165/archive/fall2015/shkapenyuk-crawler.pdf) and introduced effective load balancing strategies. _Influence:_ Practical guidance on threading and IO that influenced projects like PolyBot and others.

- **UbiCrawler (Boldi et al., 2004):** A fully distributed crawler with no central coordinator (each node was equal). It used consistent hashing on URLs to assign URL ownership to nodes, and nodes exchanged URLs in batches. _Influence:_ Proved that a peer‑to‑peer style crawler can work at scale, with near‑linear scalability. Its concepts were revived in BUbiNG a decade later [(Link)](https://github.com/LAW-Unimi/bubing).

- **IRLbot (Lee et al., 2008):** Focused on **spam avoidance** and robust performance for extreme‑scale crawling [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c). Achieved a 6.3 billion page crawl on one server in 41 days [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c). Key contributions: DRUM algorithm for URL deduplication on disk [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c), STAR algorithm to avoid spider traps by limiting crawl depth on low‑reputation domains [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c), and analysis of real‑web issues (like infinite calendars, etc.). _Influence:_ Demonstrated that careful algorithmic optimizations can push crawling into billions even without a cluster, and highlighted the importance of spam/trap handling.

- **BUbiNG (Boldi et al., 2014):** Open‑sourced a modern crawler that combined distributed crawling with high performance, aiming to be **“for the masses”** (available to anyone) [(Link)](https://github.com/LAW-Unimi/bubing). It scales linearly with resources, showing that open‑source crawlers can approach the efficiency of proprietary ones. _Influence:_ Provides a ready‑made solution for those who need a serious crawler; also a learning resource as its code and design are documented.

- **Common Crawl’s Architecture (2010s):** While not in a single paper, Common Crawl’s engineering (by Ahad Rana and others) is documented in presentations [(Link)](https://www.slideshare.net/ahad-rana/commoncrawl-infrastructure) [(Link)](https://www.slideshare.net/ahad-rana/commoncrawl-infrastructure). They used Hadoop MapReduce to post‑process crawls (parsing, deduping, generating link graphs) [(Link)](https://github.com/commoncrawl/commoncrawl-documentation). Interesting stats from CommonCrawl’s 2012 crawl: _14 billion_ URLs in the crawl DB, _2.5 billion_ fetched pages, which after deduplication became _300 million_ unique pages uploaded to S3 [(Link)](https://www.slideshare.net/ahad-rana/commoncrawl-infrastructure) [(Link)](https://github.com/commoncrawl/commoncrawl-documentation). This shows the magnitude of deduplication (billions down to hundreds of millions) and the scale of data handled. Their focus on cost‑effective cloud crawling also provides insights into running large crawls on AWS. _Resource:_ _“Building a Scalable Web Crawler with Hadoop”_ (slides by Ahad Rana) [(Link)](https://www.slideshare.net/ahad-rana/building-a-scalable-web-crawler-with-hadoop) [(Link)](https://github.com/commoncrawl/commoncrawl-documentation).

## Getting Started and Further Resources

For a practitioner aiming to **get up and running fast**, a recommended path is: start with a framework like Scrapy or StormCrawler for an initial implementation, and read up on the architecture concepts to guide your design decisions. Use Scrapy for smaller targeted crawls or as a building block in a larger system (leveraging Frontera if needed for distribution [(Link)](https://www.zyte.com/blog/scrapy-frontera-scalable-open-source-crawling/) [(Link)](https://www.zyte.com/blog/scrapy-frontera-scalable-open-source-crawling/)). If your goal is a broad crawl, Apache Nutch with Hadoop can jump‑start a batch crawl that scales to hundreds of millions of pages using commodity clusters [(Link)](https://wiki.apache.org/nutch/IndexingWithSolr). As you deploy these, refer to **engineering blogs and docs** (Zyte’s blog on Frontera [(Link)](https://www.zyte.com/blog/scrapy-frontera-scalable-open-source-crawling/), StormCrawler’s documentation [(Link)](https://stormcrawler.net/) [(Link)](https://stormcrawler.net/), etc.) for practical tips on configuration, and **academic papers** (like the ones above) for deeper techniques on optimization and trap avoidance.

By combining the use of battle‑tested tools with an understanding of the underlying concepts (distribution policies, frontier management, deduplication), you’ll be equipped to handle web crawling at scale. The references cited here – from detailed tutorials to seminal research – should serve as a solid knowledge base as you design, implement, and optimize your large‑scale web crawler. Good luck, and happy crawling!

**Sources:** The content and recommendations above are based on a variety of sources, including official tool documentation and blogs [(Link)](https://wiki.apache.org/nutch/IndexingWithSolr) [(Link)](https://stormcrawler.net/), engineering case studies [(Link)](https://www.zyte.com/blog/scrapy-frontera-scalable-open-source-crawling/) [(Link)](https://www.slideshare.net/ahad-rana/building-a-scalable-web-crawler-with-hadoop), and academic research that has influenced real‑world crawling systems [(Link)](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36991.pdf) [(Link)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0d19fe577b3e0a9d11a8a46eb623a07c). Each citation points to the relevant resource for deeper exploration.
